{% extends 'base.html' %}

{% block title %}Game Assignment{% endblock %}

{% block extra_css %}
<style>
    .week-container {
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
    }
    
    .day-container {
        border-left: 3px solid #dee2e6;
        padding: 10px 15px;
        margin: 10px 0;
    }
    
    .time-slot {
        margin-bottom: 0.75rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px dashed #dee2e6;
    }
    
    .time-slot-header {
        font-weight: bold;
        margin-bottom: 0.5rem;
        cursor: pointer;
        display: flex;
        align-items: center;
    }
    
    .time-slot-header:hover {
        color: #0d6efd;
    }
    
    .time-slot-header::before {
        content: '▼';
        font-size: 0.8rem;
        margin-right: 0.5rem;
    }
    
    .time-slot.collapsed .time-slot-header::before {
        content: '►';
    }
    
    .time-slot.collapsed .game-entries {
        display: none;
    }
    
    .game-entries {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 0.75rem;
    }
    
    .game-entry {
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 0.75rem;
        background-color: #f8f9fa;
    }
    
    .form-group {
        margin-bottom: 0.5rem;
    }
    
    .form-group label {
        display: block;
        margin-bottom: 0.25rem;
        font-weight: 500;
        font-size: 0.9rem;
    }
    
    .teams-row {
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }
    
    .teams-row .form-group {
        flex: 1;
    }
    
    .vs-label {
        margin-top: 1.5rem;
        font-weight: bold;
    }
    
    .form-actions {
        margin-top: 1.5rem;
        display: flex;
        gap: 0.5rem;
    }
    
    .week-header, .day-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        cursor: pointer;
    }
    
    .week-header:hover, .day-header:hover {
        color: #0d6efd;
    }
    
    .day-date {
        font-weight: 500;
    }
    
    .week-header::before, .day-header::before {
        content: '▼';
        font-size: 0.8rem;
        margin-right: 0.5rem;
    }
    
    .week-container.collapsed .week-header::before,
    .day-container.collapsed .day-header::before {
        content: '►';
    }
    
    .week-container.collapsed .week-content,
    .day-container.collapsed .day-content {
        display: none;
    }
    
    .other-input {
        margin-top: 0.5rem;
        display: none;
    }
    
    .other-input.visible {
        display: block;
    }
    
    .validation-result {
        padding: 15px;
        margin-bottom: 15px;
        border-radius: 5px;
    }
    
    .validation-result h5 {
        font-weight: bold;
        margin-bottom: 8px;
    }
    
    .validation-result.passed {
        background-color: #d4edda;
        border: 1px solid #c3e6cb;
    }
    
    .validation-result.failed {
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
    }
    
    .validation-message {
        margin-bottom: 10px;
    }
    
    .validation-explanation {
        font-style: italic;
        color: #666;
        margin-bottom: 10px;
    }
    
    #validationResults {
        margin-bottom: 25px;
    }
    
    #saveScheduleBtn {
        display: none;
    }
    
    #randomFillBtn {
        margin-right: auto;
    }
    
    .form-check {
        margin-top: 10px;
    }
    
    .incomplete {
        border: 2px solid #f8d7da;
    }
</style>
{% endblock %}

{% block content %}
<div class="container mt-4">
    <h2>Game Assignment</h2>

    <!-- Auto-generate Button -->
    <div class="mb-3">
        <button type="button" class="btn btn-info" id="autoGenerateBtn">Auto-generate Schedule</button>
    </div>

    <form id="gameAssignmentForm" class="mt-4" novalidate>
        {% csrf_token %}
        <input type="hidden" id="setupData" name="setupData" value="">

        <!-- Action Buttons Group 1 -->
        <div class="d-flex gap-2 mb-2">
            <button type="button" class="btn btn-warning me-auto" id="randomFillBtn">Random Fill (Dev)</button> <!-- me-auto pushes Back button right -->
            <button type="button" class="btn btn-secondary" id="backBtn">Back to Team Setup</button>
        </div>

        <!-- Action Buttons Group 2 -->
        <div class="d-flex gap-2 mb-3">
            <button type="button" class="btn btn-primary" id="validateBtn">Validate Schedule</button>
            <button type="submit" class="btn btn-success" id="saveScheduleBtn">Save Schedule</button>
        </div>

        <!-- Updated note about validation -->
        <p class="text-muted small mb-3">
            <i class="fas fa-info-circle"></i> Please click the "Validate Schedule" button. The "Save Schedule" button will appear once validation passes or failures are ignored.
        </p>

        <!-- Validation results section -->
        <div id="validationResults" style="display: none;" class="mb-4"> <!-- Added margin-bottom -->
            <!-- Validation results will be shown here -->
        </div>

        <!-- Added Title for Schedule Section -->
        <h4 class="mt-4 border-top pt-3">Schedule Details</h4>

        <div id="scheduleContainer">
            <!-- Weeks, days, and game assignments will be added here -->
        </div>
    </form>
</div>
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Hide the Save Schedule button initially
    document.getElementById('saveScheduleBtn').style.display = 'none';
    
    // Show Random Fill button only in development
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        document.getElementById('randomFillBtn').style.display = 'block';
        document.getElementById('autoGenerateBtn').style.display = 'block';
    } else {
        document.getElementById('randomFillBtn').style.display = 'none';
        document.getElementById('autoGenerateBtn').style.display = 'none';
    }
    
    // Get setup data from URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const setupDataParam = urlParams.get('setupData');
    let setupData = {};
    
    if (setupDataParam) {
        try {
            setupData = JSON.parse(decodeURIComponent(setupDataParam));
            document.getElementById('setupData').value = setupDataParam;
            
            // Render the schedule with game assignments
            renderSchedule(setupData);
        } catch (e) {
            console.error('Error parsing setup data:', e);
            alert('Invalid setup data. Please go back and try again.');
        }
    } else {
        alert('No setup data found. Please go back and complete the team setup.');
    }
    
    // Setup back button
    document.getElementById('backBtn').addEventListener('click', () => {
        history.back();
    });
    
    // Random fill button
    document.getElementById('randomFillBtn').addEventListener('click', randomFill);
    
    // Auto-generate Schedule button
    document.getElementById('autoGenerateBtn').addEventListener('click', autoGenerateSchedule);
    
    // Validate button
    document.getElementById('validateBtn').addEventListener('click', validateSchedule);
    
    // Add listener to detect changes in the schedule form after initial setup
    document.getElementById('scheduleContainer').addEventListener('change', function(event) {
        // Check if the change occurred on a relevant form element within a game entry
        if (event.target.matches('.game-entry select, .game-entry input')) {
            console.log('Schedule change detected. Resetting validation state.');
            resetValidationState();
        }
    });
    
    // Form submission
    document.getElementById('gameAssignmentForm').addEventListener('submit', function(e) {
        e.preventDefault();
        saveSchedule();
    });
    
    // Helper function to collect all game assignments
    function collectGameAssignments() {
        const gameAssignments = [];
        
        document.querySelectorAll('.game-entry').forEach(gameEntry => {
            const weekNum = gameEntry.dataset.week;
            const date = gameEntry.dataset.date;
            const time = gameEntry.dataset.time;
            const gameIndex = gameEntry.dataset.gameIndex;
            
            const levelSelect = gameEntry.querySelector('.level-select');
            const team1Select = gameEntry.querySelector('.team1-select');
            const team2Select = gameEntry.querySelector('.team2-select');
            const refSelect = gameEntry.querySelector('.ref-select');
            const refOtherInput = gameEntry.querySelector('.ref-other-input');
            const courtSelect = gameEntry.querySelector('.court-select');
            const courtOtherInput = gameEntry.querySelector('.court-other-input');
            
            // Skip incomplete entries
            if (!levelSelect.value || !team1Select.value || !team2Select.value || !refSelect.value || !courtSelect.value) {
                return;
            }
            
            // Get the ref value (either from select or other input)
            let referee = refSelect.value;
            if (referee === 'other') {
                // If it's "other", use the input value if present, otherwise just use "External Referee"
                referee = refOtherInput?.value.trim() || 'External Referee';
            }
            
            // Get the court value (either from select or other input)
            let court = courtSelect.value;
            if (court === 'other' && courtOtherInput) {
                court = courtOtherInput.value.trim() || 'Other Court';
            }
            
            gameAssignments.push({
                week: parseInt(weekNum),
                date: date,
                time: time,
                gameIndex: parseInt(gameIndex),
                level: levelSelect.value,
                team1: team1Select.value,
                team2: team2Select.value,
                referee: referee,
                court: court
            });
        });
        
        return gameAssignments;
    }
    
    // Function to validate the schedule
    function validateSchedule() {
        // Reset state before starting validation
        resetValidationState();

        // 1. Collect the current assignments from the form
        const currentAssignments = collectGameAssignments();
        // 2. Convert the assignments to the backend schedule format
        const scheduleData = webToScheduleFormat(currentAssignments);

        // Get levels and teams_per_level directly from setupData
        if (!setupData || !setupData.teams) {
             console.error('Setup data with teams information not found.');
             alert('Could not find team setup information. Please reload the page or go back.');
             return;
        }
        const levels = Object.keys(setupData.teams);
        const teams_per_level = {};
        for (const level in setupData.teams) {
            teams_per_level[level] = setupData.teams[level].length;
        }
        const minimalConfig = { levels: levels, teams_per_level: teams_per_level };

        fetch('/validate_schedule/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCsrfToken(),
            },
            body: JSON.stringify({
                schedule: scheduleData,
                config: minimalConfig
            })
        })
        .then(response => response.json())
        .then(data => {
            // Handle validation results
            window.currentValidationResults = data; // Store results globally for checkbox handlers
            displayValidationResults(data);
        })
        .catch(error => {
            console.error('Error validating schedule:', error);
            alert('Error during validation: ' + error.message);
            window.currentValidationResults = null; // Clear results on error
        });
    }
    
    // Helper function to sanitize a string for use as an ID
    function sanitizeForId(str) {
        // Replace spaces and potentially other problematic characters with hyphens
        // Keep it simple: replace spaces with hyphens and remove other non-alphanumeric chars except hyphens
        return str.replace(/\s+/g, '-').replace(/[^a-zA-Z0-9-]/g, '');
    }

    // Function to display validation results
    function displayValidationResults(results) {
        const resultsContainer = document.getElementById('validationResults');
        resultsContainer.innerHTML = '<h3 class="mb-4">Validation Results</h3>'; // Clear previous results
        resultsContainer.style.display = 'block';

        let hasFailures = false;

        // Define explanations for each validation (used as fallback or title)
        const explanations = {
            'Pairings': 'Teams must play against other teams in their level a specific number of times based on level size.',
            'Cycle Pairings': 'For levels with fewer teams, matchups must repeat in proper round-robin cycles throughout the season.',
            'Referee-Player': 'A team cannot referee any game in which they are playing.',
            'Adjacent Slots': 'Teams can only referee games in time slots that are directly before or after their own game.',
            // Add explanations for other tests if they are included in validation_results
        };

        // Iterate through the results from the backend
        for (const testName in results) {
            if (results.hasOwnProperty(testName)) {
                const result = results[testName];
                const explanation = explanations[testName] || 'No description available.'; // Fallback explanation
                const sanitizedTestName = sanitizeForId(testName); // Sanitize the test name for ID use
                const checkboxId = `ignore-${sanitizedTestName}-checkbox`; // Use sanitized name for ID

                const resultDiv = document.createElement('div');
                resultDiv.classList.add('mb-3', 'p-3', 'border', 'rounded');

                let statusIcon = '';
                let statusText = '';
                let ignoreCheckboxHTML = '';

                if (result.passed) {
                    resultDiv.classList.add('border-success');
                    statusIcon = '<i class="fas fa-check-circle text-success me-2"></i>';
                    statusText = 'Passed';
                } else {
                    hasFailures = true;
                    resultDiv.classList.add('border-danger');
                    statusIcon = '<i class="fas fa-times-circle text-danger me-2"></i>';
                    statusText = 'Failed';
                    // Add checkbox for failed tests using the sanitized ID
                    ignoreCheckboxHTML = `
                        <div class="form-check mt-2">
                            <input class="form-check-input ignore-failure-checkbox" type="checkbox" value="" id="${checkboxId}" data-test-name="${testName}">
                            <label class="form-check-label small" for="${checkboxId}">
                                Ignore this failure
                            </label>
                        </div>
                    `;
                }

                let errorListHTML = '';
                if (!result.passed && result.errors && result.errors.length > 0) {
                    errorListHTML = '<ul class="list-unstyled mt-2 mb-0 small text-muted">';
                    result.errors.forEach(error => {
                        errorListHTML += `<li><i class="fas fa-exclamation-triangle text-warning me-1"></i> ${escapeHTML(error)}</li>`; // Escape error message
                    });
                    errorListHTML += '</ul>';
                }

                resultDiv.innerHTML = `
                    <h5 class="mb-1">${statusIcon}${testName} <span class="badge bg-${result.passed ? 'success' : 'danger'}">${statusText}</span></h5>
                    <p class="mb-1 small">${explanation}</p>
                    ${errorListHTML}
                    ${ignoreCheckboxHTML}
                `;
                resultsContainer.appendChild(resultDiv);

                // Add event listener to the checkbox if it was created
                if (!result.passed) {
                    // Use the sanitized ID in the querySelector
                    const checkbox = resultDiv.querySelector(`#${checkboxId}`);
                    // Add a null check just in case, although sanitizing should prevent it
                    if (checkbox) {
                        checkbox.addEventListener('change', checkValidationAndToggleButtonState);
                    } else {
                        console.error(`Could not find checkbox with sanitized ID: #${checkboxId} for test: ${testName}`);
                    }
                }
            }
        }

        // Add a summary message container (initially empty or with basic text)
        const summaryDiv = document.createElement('div');
        summaryDiv.id = 'validationSummary'; // Give it an ID for easy access
        summaryDiv.classList.add('mt-4', 'alert');
        resultsContainer.appendChild(summaryDiv);

        // Initial check of button states after displaying results
        checkValidationAndToggleButtonState();
    }
    
    // NEW function to check validation status and toggle buttons
    function checkValidationAndToggleButtonState() {
        const results = window.currentValidationResults;
        const resultsContainer = document.getElementById('validationResults');
        const summaryDiv = document.getElementById('validationSummary');
        const saveBtn = document.getElementById('saveScheduleBtn');
        const validateBtn = document.getElementById('validateBtn');

        if (!results || resultsContainer.style.display === 'none') {
            // Validation hasn't been run or has been reset
            saveBtn.style.display = 'none';
            validateBtn.style.display = 'inline-block';
            if (summaryDiv) summaryDiv.style.display = 'none'; // Hide summary
            return;
        }

        let allPassedOrIgnored = true;
        let hasFailures = false;

        for (const testName in results) {
            if (results.hasOwnProperty(testName)) {
                if (!results[testName].passed) {
                    hasFailures = true;
                    // Use the sanitized ID to find the checkbox
                    const sanitizedTestName = sanitizeForId(testName);
                    const checkboxId = `ignore-${sanitizedTestName}-checkbox`;
                    const checkbox = document.getElementById(checkboxId);
                    if (!checkbox || !checkbox.checked) {
                        allPassedOrIgnored = false;
                        // break; // Don't break early, need to know if there were any failures at all
                    }
                }
            }
        }

        // Update summary message
        summaryDiv.classList.remove('alert-success', 'alert-warning', 'alert-danger'); // Clear previous classes
        if (allPassedOrIgnored && hasFailures) {
             summaryDiv.style.display = 'block';
             summaryDiv.classList.add('alert-warning');
             summaryDiv.innerHTML = '<strong><i class="fas fa-exclamation-triangle"></i> Some validation checks failed but are ignored.</strong> You can now save the schedule, but review ignored issues.';
        } else if (allPassedOrIgnored && !hasFailures) {
             summaryDiv.style.display = 'block';
             summaryDiv.classList.add('alert-success');
             summaryDiv.innerHTML = '<strong><i class="fas fa-thumbs-up"></i> All validation checks passed!</strong> Schedule is valid and ready to be saved.';
        } else { // Some failures are not ignored
             summaryDiv.style.display = 'block';
             summaryDiv.classList.add('alert-danger');
             summaryDiv.innerHTML = '<strong><i class="fas fa-times-circle"></i> Some validation checks failed.</strong> Please review the errors above or check "Ignore this failure" to proceed.';
        }


        // Update button visibility
        if (allPassedOrIgnored) {
            saveBtn.style.display = 'inline-block';
            validateBtn.style.display = 'none';
        } else {
            saveBtn.style.display = 'none';
            validateBtn.style.display = 'inline-block';
        }
    }
    
    // Function to get CSRF token
    function getCsrfToken() {
        const cookieValue = document.cookie
            .split('; ')
            .find(row => row.startsWith('csrftoken='))
            ?.split('=')[1];
        
        return cookieValue || '';
    }

    // Helper function to escape HTML special characters (basic version)
    function escapeHTML(str) {
        var div = document.createElement('div');
        div.appendChild(document.createTextNode(str));
        return div.innerHTML;
    }
    
    // Web to Schedule format conversion
    function webToScheduleFormat(gameAssignments) {
        // First, group by week and day
        const weekDayGroups = {};
        gameAssignments.forEach(game => {
            const weekKey = game.week;
            const dayKey = game.date;
            
            if (!weekDayGroups[weekKey]) {
                weekDayGroups[weekKey] = {};
            }
            if (!weekDayGroups[weekKey][dayKey]) {
                weekDayGroups[weekKey][dayKey] = [];
            }
            weekDayGroups[weekKey][dayKey].push(game);
        });

        // For each day, create slot numbers based on unique times
        const schedule = [];
        Object.entries(weekDayGroups).forEach(([weekNum, days]) => {
            const weekGames = {
                'week': parseInt(weekNum),
                'slots': {}
            };

            Object.entries(days).forEach(([date, games]) => {
                // Get unique times and sort them
                const times = [...new Set(games.map(g => g.time))].sort();
                
                // Map each time to a slot number (1-based)
                const timeToSlot = {};
                times.forEach((time, idx) => {
                    timeToSlot[time] = idx + 1;
                });

                // Group games by slot
                games.forEach(game => {
                    const slot = timeToSlot[game.time];
                    if (!weekGames.slots[slot]) {
                        weekGames.slots[slot] = [];
                    }
                    weekGames.slots[slot].push({
                        'level': game.level,
                        'teams': [game.team1, game.team2],
                        'ref': game.referee
                    });
                });
            });

            schedule.push(weekGames);
        });

        return schedule;
    }
    
    // Random fill function - with better handling for "other" fields
    function randomFill() {
        // Reset validation state whenever random fill is used
        resetValidationState();

        document.querySelectorAll('.game-entry').forEach(gameEntry => {
            // First select a random level
            const levelSelect = gameEntry.querySelector('.level-select');
            const levelOptions = Array.from(levelSelect.options).filter(opt => opt.value);
            
            if (levelOptions.length === 0) return;
            
            const randomLevel = levelOptions[Math.floor(Math.random() * levelOptions.length)];
            levelSelect.value = randomLevel.value;
            levelSelect.dispatchEvent(new Event('change'));

            // Use a chain of promises to ensure proper sequence
            const fillTeams = () => new Promise(resolve => {
                setTimeout(() => {
                    // Fill team 1
                    const team1Select = gameEntry.querySelector('.team1-select');
                    const team1Options = Array.from(team1Select.options).filter(opt => opt.value);
                    if (team1Options.length === 0) {
                        resolve(false);
                        return;
                    }
                    
                    let team1 = team1Options[Math.floor(Math.random() * team1Options.length)];
                    team1Select.value = team1.value;
                    team1Select.dispatchEvent(new Event('change'));
                    
                    // Fill team 2
                    const team2Select = gameEntry.querySelector('.team2-select');
                    const team2Options = Array.from(team2Select.options)
                        .filter(opt => opt.value && !opt.disabled);
                    if (team2Options.length === 0) {
                        resolve(false);
                        return;
                    }
                    
                    let team2 = team2Options[Math.floor(Math.random() * team2Options.length)];
                    team2Select.value = team2.value;
                    team2Select.dispatchEvent(new Event('change'));
                    
                    resolve(true);
                }, 100);
            });

            const fillReferee = () => new Promise(resolve => {
                setTimeout(() => {
                    const refSelect = gameEntry.querySelector('.ref-select');
                    const refOptions = Array.from(refSelect.options)
                        .filter(opt => opt.value && !opt.disabled);
                    
                    if (refOptions.length === 0) {
                        resolve();
                        return;
                    }
                    
                    // 25% chance to choose "Other" for referee
                    const useOther = Math.random() < 0.25 && refOptions.some(opt => opt.value === 'other');
                    
                    if (useOther) {
                        refSelect.value = 'other';
                        refSelect.dispatchEvent(new Event('change'));
                        
                        setTimeout(() => {
                            const refOtherInput = gameEntry.querySelector('.ref-other-input.visible');
                            if (refOtherInput) {
                                const randomNames = ['Coach Bob', 'Ref Sarah', 'Judge Mike', 'Official Jane', 
                                                'Umpire Dave', 'Referee Smith', 'Guest Ref', 'Volunteer', 
                                                'Staff Member', 'Tournament Official'];
                                refOtherInput.value = randomNames[Math.floor(Math.random() * randomNames.length)];
                            }
                            resolve();
                        }, 100);
                    } else {
                        let ref = refOptions[Math.floor(Math.random() * refOptions.length)];
                        refSelect.value = ref.value;
                        refSelect.dispatchEvent(new Event('change'));
                        resolve();
                    }
                }, 100);
            });

            const fillCourt = () => new Promise(resolve => {
                setTimeout(() => {
                    const courtSelect = gameEntry.querySelector('.court-select');
                    
                    // 20% chance of selecting "Other"
                    const useOther = Math.random() < 0.2;
                    
                    if (useOther) {
                        courtSelect.value = 'other';
                        courtSelect.dispatchEvent(new Event('change'));
                        
                        setTimeout(() => {
                            const courtOtherInput = gameEntry.querySelector('.court-other-input.visible');
                            if (courtOtherInput) {
                                const randomCourts = ['Court X', 'Outdoor Court', 'Practice Court', 
                                                    'Main Hall', 'Stadium Court', 'Court B', 'Auxiliary Court',
                                                    'Court North', 'Court South', 'Training Court'];
                                courtOtherInput.value = Math.random() < 0.5 ? 
                                    `Court ${Math.floor(Math.random() * 5) + 4}` : 
                                    randomCourts[Math.floor(Math.random() * randomCourts.length)];
                            }
                            resolve();
                        }, 100);
                    } else {
                        resolve();
                    }
                }, 100);
            });

            // Chain the promises to ensure proper sequence
            fillTeams()
                .then(success => {
                    if (success) {
                        return fillReferee();
                    }
                })
                .then(() => {
                    return fillCourt();
                })
                .catch(error => {
                    console.error('Error during random fill:', error);
                });
        });
    }
    
    // Function to render the schedule
    function renderSchedule(data) {
        const scheduleContainer = document.getElementById('scheduleContainer');
        const schedule = data.schedule;
        const teams = data.teams;
        const courts = data.courts;
        
        // Clear container
        scheduleContainer.innerHTML = '';
        
        let currentWeekNum = 0;
        
        // Create elements for each week (excluding off weeks)
        schedule.weeks.forEach((week, weekIndex) => {
            // Skip off weeks
            if (week.isOffWeek) {
                return;
            }
            
            currentWeekNum++;
            const weekContainer = createWeekElement(currentWeekNum);
            
            // Create elements for each day in the week
            week.days.forEach(day => {
                const dayContainer = createDayElement(day.date);
                
                // Create elements for each time slot in the day
                day.times.forEach(timeSlot => {
                    const timeSlotElement = createTimeSlotElement(timeSlot.time);
                    const gameEntriesContainer = document.createElement('div');
                    gameEntriesContainer.className = 'game-entries';
                    
                    // Create a game entry for each court available in this time slot
                    for (let i = 0; i < timeSlot.courts; i++) {
                        // Determine the default court
                        const defaultCourtIndex = timeSlot.courts > courts.length ? 
                            i : // If more courts needed than available, just use sequential
                            courts.length - timeSlot.courts + i; // Start from the end for defaults
                        
                        const defaultCourt = defaultCourtIndex >= 0 && defaultCourtIndex < courts.length ? 
                            courts[defaultCourtIndex] : '';
                        
                        const gameEntry = createGameEntryElement(
                            teams,
                            courts,
                            defaultCourt,
                            currentWeekNum,
                            day.date,
                            timeSlot.time,
                            i
                        );
                        
                        gameEntriesContainer.appendChild(gameEntry);
                    }
                    
                    timeSlotElement.appendChild(gameEntriesContainer);
                    dayContainer.querySelector('.day-content').appendChild(timeSlotElement);
                });
                
                weekContainer.querySelector('.week-content').appendChild(dayContainer);
            });
            
            scheduleContainer.appendChild(weekContainer);
        });
        
        // Add collapsible functionality
        setupCollapsible();
    }
    
    // Helper function to create a week element
    function createWeekElement(weekNum) {
        const weekContainer = document.createElement('div');
        weekContainer.className = 'week-container';
        weekContainer.innerHTML = `
            <div class="week-header">
                <h4>Week ${weekNum}</h4>
            </div>
            <div class="week-content">
                <!-- Days will be added here -->
            </div>
        `;
        
        return weekContainer;
    }
    
    // Helper function to create a day element
    function createDayElement(date) {
        const dayName = new Date(date).toLocaleDateString('en-US', { weekday: 'long' });
        const formattedDate = new Date(date).toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric' 
        });
        
        const dayContainer = document.createElement('div');
        dayContainer.className = 'day-container';
        dayContainer.innerHTML = `
            <div class="day-header">
                <div class="day-date">${dayName}, ${formattedDate}</div>
            </div>
            <div class="day-content">
                <!-- Time slots will be added here -->
            </div>
        `;
        
        return dayContainer;
    }
    
    // Helper function to create a time slot element
    function createTimeSlotElement(time) {
        const timeSlot = document.createElement('div');
        timeSlot.className = 'time-slot';
        
        // Format time for display (24h to 12h)
        const formattedTime = format12HourTime(time);
        
        timeSlot.innerHTML = `
            <div class="time-slot-header">${formattedTime}</div>
            <!-- Game entries will be added here -->
        `;
        
        return timeSlot;
    }
    
    // Helper function to create a game entry element
    function createGameEntryElement(teams, courts, defaultCourt, weekNum, date, time, gameIndex) {
        const gameEntry = document.createElement('div');
        gameEntry.className = 'game-entry';
        gameEntry.dataset.week = weekNum;
        gameEntry.dataset.date = date;
        gameEntry.dataset.time = time;
        gameEntry.dataset.gameIndex = gameIndex;
        
        // Create level options
        let levelOptions = '<option value="">Select Level</option>';
        Object.keys(teams).forEach(level => {
            levelOptions += `<option value="${level}">${level}</option>`;
        });
        
        // Create court options with "Other" option
        let courtOptions = '<option value="">Select Court</option>';
        courts.forEach(court => {
            const selected = court === defaultCourt ? 'selected' : '';
            courtOptions += `<option value="${court}" ${selected}>${court}</option>`;
        });
        courtOptions += '<option value="other">Other...</option>';
        
        gameEntry.innerHTML = `
            <div class="form-group">
                <label>Level:</label>
                <select class="form-control level-select" required>
                    ${levelOptions}
                </select>
            </div>
            <div class="teams-row">
                <div class="form-group">
                    <label>Team 1:</label>
                    <select class="form-control team1-select" required disabled>
                        <option value="">Select Team</option>
                    </select>
                </div>
                <div class="vs-label">vs</div>
                <div class="form-group">
                    <label>Team 2:</label>
                    <select class="form-control team2-select" required disabled>
                        <option value="">Select Team</option>
                    </select>
                </div>
            </div>
            <div class="form-group">
                <label>Referee:</label>
                <select class="form-control ref-select" required disabled>
                    <option value="">Select Team</option>
                </select>
                <input type="text" class="form-control ref-other-input other-input" 
                       placeholder="Enter referee name (optional)">
            </div>
            <div class="form-group">
                <label>Court:</label>
                <select class="form-control court-select" required>
                    ${courtOptions}
                </select>
                <input type="text" class="form-control court-other-input other-input" 
                       placeholder="Enter court name" required>
            </div>
        `;
        
        // Setup level selection event to populate team dropdowns
        const levelSelect = gameEntry.querySelector('.level-select');
        const team1Select = gameEntry.querySelector('.team1-select');
        const team2Select = gameEntry.querySelector('.team2-select');
        const refSelect = gameEntry.querySelector('.ref-select');
        
        levelSelect.addEventListener('change', function() {
            const selectedLevel = this.value;
            
            // Reset and disable team dropdowns if no level selected
            if (!selectedLevel) {
                resetTeamDropdowns(team1Select, team2Select, refSelect);
                return;
            }
            
            // Enable and populate team dropdowns
            const teamsInLevel = teams[selectedLevel] || [];
            populateTeamDropdowns(teamsInLevel, team1Select, team2Select, refSelect);
        });
        
        // Setup team selection to prevent duplicate selections
        team1Select.addEventListener('change', () => updateTeamOptions(team1Select, team2Select, refSelect));
        team2Select.addEventListener('change', () => updateTeamOptions(team1Select, team2Select, refSelect));
        
        // Setup other input handlers
        setupOtherInputHandlers(gameEntry);
        
        return gameEntry;
    }
    
    // Helper function to show/hide "Other" input fields
    function setupOtherInputHandlers(gameEntry) {
        const refSelect = gameEntry.querySelector('.ref-select');
        const refOtherInput = gameEntry.querySelector('.ref-other-input');
        const courtSelect = gameEntry.querySelector('.court-select');
        const courtOtherInput = gameEntry.querySelector('.court-other-input');
        
        refSelect.addEventListener('change', function() {
            if (this.value === 'other') {
                refOtherInput.classList.add('visible');
            } else {
                refOtherInput.classList.remove('visible');
            }
        });
        
        courtSelect.addEventListener('change', function() {
            if (this.value === 'other') {
                courtOtherInput.classList.add('visible');
            } else {
                courtOtherInput.classList.remove('visible');
            }
        });
    }
    
    // Helper function to format time from 24h to 12h
    function format12HourTime(time24h) {
        const [hours, minutes] = time24h.split(':');
        const hour = parseInt(hours);
        const period = hour >= 12 ? 'PM' : 'AM';
        const hour12 = hour % 12 || 12;
        return `${hour12}:${minutes} ${period}`;
    }
    
    // Helper function to reset team dropdowns
    function resetTeamDropdowns(...dropdowns) {
        dropdowns.forEach(dropdown => {
            dropdown.innerHTML = '<option value="">Select Team</option>';
            dropdown.disabled = true;
        });
    }
    
    // Helper function to populate team dropdowns
    function populateTeamDropdowns(teams, ...dropdowns) {
        dropdowns.forEach(dropdown => {
            dropdown.innerHTML = '<option value="">Select Team</option>';
            teams.forEach(team => {
                dropdown.innerHTML += `<option value="${team}">${team}</option>`;
            });
            
            // Add "Other" option for referee dropdown
            if (dropdown === dropdowns[2]) { // referee is the third dropdown
                dropdown.innerHTML += '<option value="other">Other...</option>';
            }
            
            dropdown.disabled = false;
        });
    }
    
    // Helper function to update team options to prevent duplicates
    function updateTeamOptions(team1Select, team2Select, refSelect) {
        const selectedTeams = [
            team1Select.value,
            team2Select.value
        ].filter(Boolean);
        
        // Get all available teams from the first dropdown (they all have the same options)
        const allTeams = Array.from(team1Select.options)
            .map(option => option.value)
            .filter(value => value && value !== 'other');
        
        // Update each team dropdown
        [team1Select, team2Select].forEach(dropdown => {
            const currentValue = dropdown.value;
            
            // Store current selection
            dropdown.innerHTML = '<option value="">Select Team</option>';
            
            // Re-add all options, disabling those already selected in other dropdowns
            allTeams.forEach(team => {
                const isSelected = team === currentValue;
                const isDisabled = selectedTeams.includes(team) && !isSelected;
                
                dropdown.innerHTML += `
                    <option value="${team}" 
                        ${isSelected ? 'selected' : ''} 
                        ${isDisabled ? 'disabled' : ''}>
                        ${team}
                    </option>
                `;
            });
        });
        
        // Update ref dropdown - can't ref if playing
        const currentRefValue = refSelect.value;
        refSelect.innerHTML = '<option value="">Select Team</option>';
        
        allTeams.forEach(team => {
            const isSelected = team === currentRefValue;
            const isDisabled = selectedTeams.includes(team);
            
            refSelect.innerHTML += `
                <option value="${team}" 
                    ${isSelected ? 'selected' : ''} 
                    ${isDisabled ? 'disabled' : ''}>
                    ${team}
                </option>
            `;
        });
        
        // Add "Other" option for referee
        refSelect.innerHTML += `
            <option value="other" ${currentRefValue === 'other' ? 'selected' : ''}>
                Other...
            </option>
        `;
        
        // Show/hide other input field
        const refOtherInput = refSelect.closest('.form-group').querySelector('.ref-other-input');
        if (refOtherInput) {
            if (currentRefValue === 'other') {
                refOtherInput.classList.add('visible');
            } else {
                refOtherInput.classList.remove('visible');
            }
        }
    }
    
    // Setup collapsible elements
    function setupCollapsible() {
        // Add click handlers to all week headers
        document.querySelectorAll('.week-header').forEach(header => {
            header.addEventListener('click', function() {
                const weekContainer = this.closest('.week-container');
                weekContainer.classList.toggle('collapsed');
            });
        });
        
        // Add click handlers to all day headers
        document.querySelectorAll('.day-header').forEach(header => {
            header.addEventListener('click', function() {
                const dayContainer = this.closest('.day-container');
                dayContainer.classList.toggle('collapsed');
            });
        });
        
        // Add click handlers to all time slot headers
        document.querySelectorAll('.time-slot-header').forEach(header => {
            header.addEventListener('click', function() {
                const timeSlot = this.closest('.time-slot');
                timeSlot.classList.toggle('collapsed');
            });
        });
    }

    function autoGenerateSchedule() {
        const setupDataParam = document.getElementById('setupData').value;
        
        if (!setupDataParam) {
            console.error('No setup data available');
            return;
        }
        
        // Show loading indicator or message
        console.log('Generating schedule, please wait...');
        
        fetch('/auto_generate_schedule/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCsrfToken(),
            },
            body: JSON.stringify({
                setupData: setupDataParam
            })
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(data => {
                    throw new Error(data.error || 'Failed to generate schedule');
                });
            }
            return response.json();
        })
        .then(data => {
            console.log('Configuration from schedule creator:', data.config);
            console.log('Generated schedule:', data.schedule);
            
            // Fill the form with the generated schedule
            fillFormWithSchedule(data.schedule);
        })
        .catch(error => {
            console.error('Error generating schedule:', error);
            alert('Error generating schedule: ' + error.message);
        });
    }

    // Function to fill the form with the generated schedule
    function fillFormWithSchedule(schedule) {
        console.log('Starting to fill form with schedule:', JSON.stringify(schedule));
        
        // Get all game entries in the form
        const gameEntries = document.querySelectorAll('.game-entry');
        console.log(`Found ${gameEntries.length} game entries in the form`);
        
        // Map each form game entry to its week and time slot
        const formGameEntryMap = {};
        
        // Group the form's game entries by week and time
        gameEntries.forEach((gameEntry) => {
            const weekNum = parseInt(gameEntry.dataset.week);
            const timeSlot = gameEntry.dataset.time;
            
            if (!formGameEntryMap[weekNum]) {
                formGameEntryMap[weekNum] = {};
            }
            
            if (!formGameEntryMap[weekNum][timeSlot]) {
                formGameEntryMap[weekNum][timeSlot] = [];
            }
            
            formGameEntryMap[weekNum][timeSlot].push(gameEntry);
        });
        
        console.log('Form game entry map:', formGameEntryMap);
        
        // Process each week in the generated schedule
        schedule.forEach(week => {
            const weekNum = week.week;
            if (!weekNum) {
                console.error('Week number is undefined in schedule item:', week);
                return; // Skip this week
            }
            
            console.log(`Processing week ${weekNum}`);
            
            if (!week.slots || Object.keys(week.slots).length === 0) {
                console.log(`No slots for week ${weekNum}`);
                return; // Skip this week
            }
            
            if (!formGameEntryMap[weekNum]) {
                console.log(`No form entries for week ${weekNum}`);
                return; // Skip this week
            }
            
            // Get the times for this week in the form, sorted
            const times = Object.keys(formGameEntryMap[weekNum]).sort();
            console.log(`Times for week ${weekNum}:`, times);
            
            // Map each time to a slot (1-based index)
            const timeToSlot = {};
            times.forEach((time, idx) => {
                timeToSlot[time] = (idx + 1).toString(); // Convert to string to match slots keys
            });
            
            console.log(`Time to slot mapping for week ${weekNum}:`, timeToSlot);
            console.log(`Available slots in schedule for week ${weekNum}:`, Object.keys(week.slots));
            
            // For each time in this week, find and assign games
            times.forEach(time => {
                const slotNumber = timeToSlot[time];
                console.log(`Processing time ${time} (slot ${slotNumber})`);
                
                // Get the games for this slot from the schedule
                const gamesForSlot = week.slots[slotNumber] || [];
                console.log(`Found ${gamesForSlot.length} games for slot ${slotNumber}`);
                
                // Get the game entries for this time in the form
                const entriesForTime = formGameEntryMap[weekNum][time] || [];
                console.log(`Found ${entriesForTime.length} form entries for time ${time}`);
                
                // Assign games to entries
                gamesForSlot.forEach((game, gameIndex) => {
                    if (gameIndex < entriesForTime.length) {
                        console.log(`Assigning game to entry ${gameIndex}:`, game);
                        fillGameEntry(entriesForTime[gameIndex], game);
                    } else {
                        console.log(`No form entry for game ${gameIndex}`);
                    }
                });
            });
        });
        
        alert('Schedule loading process completed!');
    }

    // Helper function to fill a single game entry
    function fillGameEntry(gameEntry, game) {
        console.log('Filling game entry with:', game);
        
        // Set the level
        const levelSelect = gameEntry.querySelector('.level-select');
        console.log(`Setting level to: ${game.level}. Available options:`, 
            Array.from(levelSelect.options).map(o => o.value));
        
        levelSelect.value = game.level;
        levelSelect.dispatchEvent(new MouseEvent('change', { bubbles: true }));
        
        // Use setTimeout to ensure the team dropdowns get populated
        setTimeout(() => {
            // Set teams
            const team1Select = gameEntry.querySelector('.team1-select');
            const team2Select = gameEntry.querySelector('.team2-select');
            
            console.log(`Team1 options:`, Array.from(team1Select.options).map(o => o.value));
            console.log(`Setting team1 to: ${game.teams[0]}`);
            team1Select.value = game.teams[0];
            team1Select.dispatchEvent(new MouseEvent('change', { bubbles: true }));
            
            setTimeout(() => {
                console.log(`Team2 options:`, Array.from(team2Select.options).map(o => o.value));
                console.log(`Setting team2 to: ${game.teams[1]}`);
                team2Select.value = game.teams[1];
                team2Select.dispatchEvent(new MouseEvent('change', { bubbles: true }));
                
                // Set referee
                setTimeout(() => {
                    const refSelect = gameEntry.querySelector('.ref-select');
                    console.log(`Ref options:`, Array.from(refSelect.options).map(o => o.value));
                    console.log(`Setting referee to: ${game.ref}`);
                    
                    const refOptions = Array.from(refSelect.options).map(opt => opt.value);
                    
                    if (refOptions.includes(game.ref)) {
                        refSelect.value = game.ref;
                        refSelect.dispatchEvent(new MouseEvent('change', { bubbles: true }));
                    } else {
                        // Handle external referee
                        refSelect.value = 'other';
                        refSelect.dispatchEvent(new MouseEvent('change', { bubbles: true }));
                        
                        setTimeout(() => {
                            const refOtherInput = gameEntry.querySelector('.ref-other-input.visible');
                            if (refOtherInput) {
                                refOtherInput.value = game.ref;
                            } else {
                                console.warn('Could not find visible ref other input');
                            }
                        }, 100);
                    }
                }, 100);
            }, 100);
        }, 300);
    }

    // Function to reset button visibility and validation results
    function resetValidationState() {
        document.getElementById('saveScheduleBtn').style.display = 'none';
        document.getElementById('validateBtn').style.display = 'inline-block';
        const validationResults = document.getElementById('validationResults');
        validationResults.style.display = 'none';
        validationResults.innerHTML = ''; // Clear previous results
        window.currentValidationResults = null; // Clear stored results
    }

    // Function to save the schedule
    function saveSchedule() {
        // Get the season name - first make sure we have a modal to collect it
        const seasonName = prompt("Please enter a name for this season (e.g., '24/25 Season 1'):");
        if (!seasonName || seasonName.trim() === '') {
            alert('A season name is required to save the schedule.');
            return;
        }

        // Get the setup data
        const setupDataRaw = document.getElementById('setupData').value;
        if (!setupDataRaw) {
            alert('No setup data available. Please go back to team setup.');
            return;
        }
        
        const setupData = JSON.parse(setupDataRaw);
        
        // Collect game assignments from the form
        const gameAssignments = collectGameAssignments();
        if (gameAssignments.length === 0) {
            alert('No games to save. Please create some games first.');
            return;
        }
        
        // Create the payload
        const payload = {
            season_name: seasonName.trim(),
            setupData: setupData,
            game_assignments: gameAssignments
        };
        
        // Show loading state
        const saveBtn = document.getElementById('saveScheduleBtn');
        const originalSaveBtnText = saveBtn.innerHTML;
        saveBtn.disabled = true;
        saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Saving...';
        
        // Send the data to the server
        fetch('/save_schedule/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCsrfToken(),
            },
            body: JSON.stringify(payload)
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(data => {
                    throw new Error(data.message || 'Failed to save schedule');
                });
            }
            return response.json();
        })
        .then(data => {
            console.log('Save response:', data);
            
            // Create a success message with appropriate styling
            let messageHTML = '';
            
            if (data.status === 'success') {
                messageHTML = `
                    <div class="alert alert-success">
                        <h5><i class="fas fa-check-circle"></i> Schedule Saved!</h5>
                        <p>${escapeHTML(data.message)}</p>
                        <p>Created ${data.games_created} games in Season ID: ${data.season_id}</p>
                    </div>
                `;
            } else if (data.status === 'warning') {
                messageHTML = `
                    <div class="alert alert-warning">
                        <h5><i class="fas fa-exclamation-triangle"></i> Schedule Partially Saved</h5>
                        <p>${escapeHTML(data.message)}</p>
                        <p>Created ${data.games_created} games in Season ID: ${data.season_id}</p>
                        <p>There were ${data.errors.length} errors:</p>
                        <ul class="small">
                            ${data.errors.slice(0, 5).map(err => `<li>${escapeHTML(err)}</li>`).join('')}
                            ${data.errors.length > 5 ? `<li>...and ${data.errors.length - 5} more</li>` : ''}
                        </ul>
                    </div>
                `;
            }
            
            // Display the result
            const validationResults = document.getElementById('validationResults');
            validationResults.innerHTML = messageHTML;
            validationResults.style.display = 'block';
            
            // Scroll to show the message
            validationResults.scrollIntoView({ behavior: 'smooth' });
        })
        .catch(error => {
            console.error('Error saving schedule:', error);
            
            // Show error message
            const validationResults = document.getElementById('validationResults');
            validationResults.innerHTML = `
                <div class="alert alert-danger">
                    <h5><i class="fas fa-times-circle"></i> Error Saving Schedule</h5>
                    <p>${escapeHTML(error.message || 'An unexpected error occurred')}</p>
                </div>
            `;
            validationResults.style.display = 'block';
            
            // Scroll to show the message
            validationResults.scrollIntoView({ behavior: 'smooth' });
        })
        .finally(() => {
            // Reset button state
            saveBtn.disabled = false;
            saveBtn.innerHTML = originalSaveBtnText;
        });
    }
});
</script>
{% endblock %} 